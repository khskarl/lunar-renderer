#version 450 core
// #include <shared.glsl>

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0) uniform sampler3D u_voxel_albedo;
layout (binding = 1) uniform sampler3D u_voxel_normal;
layout (binding = 2) uniform sampler3D u_voxel_emission;

layout (binding = 2, rgba8) uniform image3D u_voxel_radiance;

uniform int u_width;
uniform int u_height;
uniform int u_depth;

// vec4 direct_lighting(vec3 position, vec3 normal, vec3 albedo)
// {
// 	float voxel_size = 2.0 / float(vxgi_options.dimension);
// 	position = position + normal * voxel_size; // move position forward to avoid shadowing errors

// 	float visibility = 1.0 - in_sun_shadow(sun.space_matrix * vec4(position, 1.0), normal);
// 	vec3 light_direction = normalize(sun.position.xyz);

// 	vec3 weight = normal * normal;

// 	// calculate directional normal attenuation
// 	float XdotL = dot(vec3(1.0, 0.0, 0.0), light_direction);
// 	float YdotL = dot(vec3(0.0, 1.0, 0.0), light_direction);
// 	float ZdotL = dot(vec3(0.0, 0.0, 1.0), light_direction);

// 	XdotL = normal.x > 0.0 ? max(XdotL, 0.0) : max(-XdotL, 0.0);
// 	YdotL = normal.y > 0.0 ? max(YdotL, 0.0) : max(-YdotL, 0.0);
// 	ZdotL = normal.z > 0.0 ? max(ZdotL, 0.0) : max(-ZdotL, 0.0);

// 	// voxel shading average from all front sides
// 	float NdotL = XdotL * weight.x + YdotL * weight.y + ZdotL * weight.z;

// 	vec3 diffuse = vec3(sun.diffuse);
// 	vec3 radiance = diffuse * albedo * NdotL * visibility;

// 	return vec4(radiance, visibility);
// }

const float PI = 3.14159265f;
const float EPSILON = 1e-30;

vec3 decode_normal(vec3 normal) {
	return normal * 2.0 - vec3(1.0);
}

void main() {
	if(any(greaterThan(gl_GlobalInvocationID, vec3(u_width, u_height, u_depth))))
		return;

	ivec3 coordinate = ivec3(gl_GlobalInvocationID);
	vec4 albedo = texelFetch(u_voxel_albedo, coordinate, 0);

	if(albedo.a < EPSILON)
		return;

	vec3 normal = texelFetch(u_voxel_normal, coordinate, 0).rgb;
	normal = normalize(decode_normal(normal));

	vec3 emission = texelFetch(u_voxel_emission, coordinate, 0).rgb;

	// black voxel has no irradiance diffuse
	if(any(greaterThan(albedo.rgb, vec3(0.0)))) {
		// obtain world-space position of the current voxel
		vec3 position = vec3(coordinate) / vec3(u_width, u_height, u_depth);
		vec3 position_ws = position * 2.0 - 1.0;

		// calculate direct lighting onto voxel
		// albedo = direct_lighting(position_ws, normal, albedo.rgb);
		albedo = albedo.rgba;

		imageStore(u_voxel_radiance, coordinate, vec4(albedo.rgb, 1.0));
	}
}
